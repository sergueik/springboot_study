##### Imports #####
import "tfplan/v2" as tfplan
import "strings"
import "types"

### find_resources_with_standard_labels ###
find_resources = func(type) {
	resources = []
	for tfplan.resource_changes as address, rc {
		if rc.type is type and
			rc.mode is "managed" and
			(rc.change.actions contains "create" or rc.change.actions contains "update" or
				rc.change.actions contains "read" or
				(rc.change.actions contains "no-op" and
					rc.change.after is not null)) {
			// print (address)
			append(resources, rc)

		}
	}

	return resources

}

filter_attribute_is_value = func(resources, attr, value, prtmsg) {
	violators = {}
	messages = {}
	for resources as address, rc {
		v = evaluate_attribute(rc, attr) else null
		if v is null {
			v = "null"
		}
		if v is value {
			# Add the resource and a warning message to the violators list
			message = to_string(address) + " has " + to_string(attr) + " with value " +
				to_string(v) +
				" that is not allowed."
			violators[address] = rc
			messages[address] = message
			if prtmsg {
				print(message)
			}
		}
	}
	return {"resources": violators, "messages": messages}
}

### filter

evaluate_attribute = func(r, attribute) {

	# Split the attribute into a list, using "." as the separator
	attributes = strings.split(attribute, ".")

	# Convert numeric strings to integers for indices
	if attributes[0] matches "^[0-9]+$" {
		a = int(attributes[0])
		# Make sure r is of type list
		if types.type_of(r) is not "list" {
			return undefined
		}
	} else {
		a = attributes[0]
	}

	# Append the current attribute to the resource instance
	if (types.type_of(r) is "map" and "change" in keys(r)) and
		(types.type_of(r.change) is "map" and "after" in keys(r.change)) {
		new_r = r.change.after[a] else null
	} else {
		new_r = r[a] else null
	}

	# Process based on length of attributes
	# being greater than or equal to 1
	if length(attributes) > 1 {

		# Strip first element from attributes
		attributes = attributes[1:length(attributes)]
		attribute = strings.join(attributes, ".")

		# Make recursive call
		return evaluate_attribute(new_r, attribute)
	} else {

		# We reached the end of the attribute and can stop the
		# recursive calls and return the value of the attribute
		return new_r

	}
}

### p
to_string = func(obj) {
	case types.type_of(obj) {
		when "string":
			return obj
		when "int", "float", "bool":
			return string(obj)
		when "null":
			return "null"
		when "undefined":
			return "undefined"
		when "list":
			output = "["
			lastIndex = length(obj) - 1
			for obj as index, value {
				if index < lastIndex {
					output += to_string(value) + ", "
				} else {
					output += to_string(value)
				}
			}
			output += "]"
			return output
		when "map":
			output = "{"
			theKeys = keys(obj)
			lastIndex = length(theKeys) - 1
			for theKeys as index, key {
				if index < lastIndex {
					output += to_string(key) + ": " + to_string(obj[key]) + ", "
				} else {
					output += to_string(key) + ": " + to_string(obj[key])
				}
			}
			output += "}"
			return output
		else:
			return ""
	}
}

get_resources_attribute = func(resources, attribute) {
	res = {}
	for resources as address, rc {
		v = evaluate_attribute(rc, attribute) else null
		if v is null {
			v = "null"
		}
		res[address] = v
	}
	return values(res)
}

service_account_iam_member = find_resources("google_service_account_iam_member")
role = "roles/iam.serviceAccountTokenCreator"
keyadmins = filter_attribute_is_value(service_account_iam_member, "role", role, false).resources
print("keyadmins: ",length(keyadmins))
attributes = get_resources_attribute(keyadmins, "member")

filter_attribute_matches_regex = func(items, attr, expr, prtmsg) {
  violators = {}
	messages = {}
  for items as index, item {
    val = evaluate_attribute(item, attr) else null
print("val: ", val)	
    if val is null {
      val = "null"
    }
    # Process lists and maps
    if types.type_of(val) in ["list", "map"] {
      message = ""
      # Check each item of list or map
      for val as i, v {
        if v matches expr {
          # Add to the warning message
          message += to_string(index) + " has " + to_string(attr) +
                    " with value " + to_string(v) +
                    " that matches the regex " + to_string(expr) + "\n"
        }
        if message is not "" {
          # Add the item and warning message to the violators list
          violators[index] = item
          messages[index] = message
          if prtmsg {
            print(message)
          }
        } // end message not ""
      } // end for
    } else {
      # Process single item
      if val matches expr {
print("val matches: ", val)	
        # Add the item and a warning message to the violators list
        message = to_string(index) + " has " + to_string(attr) +
                  " with value " + to_string(val) +
                  " that matches the regex " + to_string(expr)
        violators[index] = item
        messages[index] = message
        if prtmsg {
          print(message)
        }
      } // end if single item not matches
    } // end single item
  } // end for items
  return {"resources":violators,"messages":messages}
}


useradmins = filter_attribute_matches_regex(keyadmins, "member", "user:.*", false).resources
print("useradmins", length(useradmins))
users = ["john.doe@gmail.com", "jane@gmail.com"]
users_prefix = [] 
for users as _,u {
  append(users_prefix , "user:" + u)
}
// violatingResources =  filter_attribute_in_list(useradmins,  "member", users_prefix, true)


violations = length(attributes)

//
print("step 5", violations)

# Main rule
main = rule {
	violations is 0
}
